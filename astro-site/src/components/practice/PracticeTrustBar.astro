---
interface StatItem {
  value: string;
  label: string;
  icon?: string;
}

interface Props {
  items: StatItem[];
}

const { items } = Astro.props;
---

<section class="trust-bar" id="practice-trust">
  <!-- Premium Mesh Gradient Background -->
  <div class="trust-bg">
    <div class="trust-orb trust-orb-1"></div>
    <div class="trust-orb trust-orb-2"></div>
    <!-- Subtle grid pattern -->
    <div class="trust-grid-pattern"></div>
  </div>

  <div class="container">
    <div class="trust-grid">
      {items.map((item, index) => (
        <div
          class="stat-card stat-card-reveal"
          data-index={index}
        >
          <!-- Spotlight Effect -->
          <div class="stat-spotlight"></div>
          <div class="stat-content">
            {item.icon && (
              <div class="stat-icon">
                <span>{item.icon}</span>
              </div>
            )}
            <div class="stat-value" data-value={item.value} data-target={item.value.replace(/[^0-9]/g, '')} data-suffix={item.value.replace(/[0-9]/g, '')}>
              <span class="counter-number">0</span><span class="counter-suffix">{item.value.replace(/[0-9]/g, '')}</span>
            </div>
            <div class="stat-label">{item.label}</div>
          </div>
          <div class="stat-glow"></div>
        </div>
      ))}
    </div>
  </div>
</section>

<style>
  .trust-bar {
    position: relative;
    padding: var(--space-16) 0;
    /* Premium gradient background using system variables */
    background: var(--practice-bg-blue-light, linear-gradient(180deg, #dbeafe 0%, #eff6ff 50%, #f8fafc 100%));
    border-bottom: 1px solid rgba(59, 130, 246, 0.06);
    overflow: hidden;
  }

  /* ========================================
     PREMIUM MESH GRADIENT BACKGROUND
     ======================================== */
  .trust-bg {
    position: absolute;
    inset: 0;
    pointer-events: none;
    overflow: hidden;
  }

  .trust-orb {
    position: absolute;
    border-radius: 50%;
    filter: blur(120px);
    will-change: transform;
  }

  .trust-orb-1 {
    top: -20%;
    left: 10%;
    width: 500px;
    height: 500px;
    background: radial-gradient(circle, var(--orb-blue-strong, rgba(59, 130, 246, 0.15)) 0%, transparent 70%);
    animation: trustOrbFloat 20s ease-in-out infinite;
  }

  .trust-orb-2 {
    bottom: -30%;
    right: 15%;
    width: 400px;
    height: 400px;
    background: radial-gradient(circle, var(--orb-gold-strong, rgba(201, 169, 97, 0.12)) 0%, transparent 70%);
    animation: trustOrbFloat 25s ease-in-out infinite reverse;
  }

  @keyframes trustOrbFloat {
    0%, 100% {
      transform: translate(0, 0) scale(1);
      opacity: 0.8;
    }
    25% {
      transform: translate(40px, -30px) scale(1.05);
      opacity: 1;
    }
    50% {
      transform: translate(-20px, 20px) scale(0.95);
      opacity: 0.9;
    }
    75% {
      transform: translate(30px, 10px) scale(1.02);
      opacity: 1;
    }
  }

  .trust-grid-pattern {
    position: absolute;
    inset: 0;
    background-image:
      linear-gradient(rgba(59, 130, 246, 0.025) 1px, transparent 1px),
      linear-gradient(90deg, rgba(59, 130, 246, 0.025) 1px, transparent 1px);
    background-size: 48px 48px;
  }

  /* ========================================
     CONTAINER
     ======================================== */
  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 var(--space-6);
    position: relative;
    z-index: 10;
  }

  /* ========================================
     GRID
     ======================================== */
  .trust-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    gap: var(--space-6);
  }

  /* ========================================
     STAT CARDS - Premium Glass Design
     ======================================== */
  .stat-card {
    position: relative;
    /* Light glass base state using system variables */
    background: var(--glass-light-bg, rgba(255, 255, 255, 0.92));
    backdrop-filter: var(--glass-blur-light, blur(12px));
    -webkit-backdrop-filter: var(--glass-blur-light, blur(12px));
    padding: var(--space-8) var(--space-6);
    border-radius: 24px;
    text-align: center;
    border: 1px solid var(--glass-light-border, rgba(255, 255, 255, 0.6));
    transition:
      transform 0.5s cubic-bezier(0.16, 1, 0.3, 1),
      background 0.5s cubic-bezier(0.4, 0, 0.2, 1),
      border-color 0.5s ease,
      box-shadow 0.5s cubic-bezier(0.16, 1, 0.3, 1);
    overflow: hidden;
    box-shadow:
      0 4px 6px -1px rgba(0, 0, 0, 0.04),
      0 2px 4px -1px rgba(0, 0, 0, 0.02),
      inset 0 1px 0 rgba(255, 255, 255, 0.7);
  }

  /* Hover: Transition to dark navy glass */
  .stat-card:hover {
    transform: translateY(-10px) scale(1.02);
    /* Dark glass hover state */
    background: var(--glass-dark-bg, rgba(12, 35, 64, 0.92));
    backdrop-filter: var(--glass-blur-heavy, blur(16px));
    -webkit-backdrop-filter: var(--glass-blur-heavy, blur(16px));
    border-color: var(--glass-dark-border, rgba(255, 255, 255, 0.15));
    box-shadow:
      0 25px 50px -12px var(--shadow-blue-glow, rgba(59, 130, 246, 0.25)),
      0 0 0 1px rgba(59, 130, 246, 0.1),
      0 0 60px var(--shadow-gold-glow-light, rgba(201, 169, 97, 0.1));
  }

  /* Spotlight Effect */
  .stat-spotlight {
    position: absolute;
    inset: 0;
    background: radial-gradient(
      400px circle at var(--mouse-x, 50%) var(--mouse-y, 50%),
      var(--shadow-gold-glow-light, rgba(201, 169, 97, 0.15)),
      transparent 40%
    );
    opacity: 0;
    transition: opacity 0.4s ease;
    pointer-events: none;
    z-index: 1;
  }

  .stat-card:hover .stat-spotlight {
    opacity: 1;
  }

  /* Pulse animation for counter */
  .stat-card.pulse {
    animation: statCardPulse 0.6s cubic-bezier(0.16, 1, 0.3, 1);
  }

  @keyframes statCardPulse {
    0%, 100% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.05);
      box-shadow:
        0 12px 30px var(--shadow-gold-glow, rgba(201, 169, 97, 0.25)),
        0 0 0 4px rgba(201, 169, 97, 0.15);
    }
  }

  /* Glow Effect */
  .stat-glow {
    position: absolute;
    inset: 0;
    background: radial-gradient(
      ellipse 80% 50% at 50% 100%,
      var(--shadow-gold-glow-light, rgba(201, 169, 97, 0.12)) 0%,
      transparent 50%
    );
    opacity: 0;
    transition: opacity 0.4s ease;
    pointer-events: none;
  }

  .stat-card:hover .stat-glow {
    opacity: 1;
  }

  /* Content */
  .stat-content {
    position: relative;
    z-index: 5;
  }

  /* Icon with Pulse Glow */
  .stat-icon {
    position: relative;
    width: 64px;
    height: 64px;
    margin: 0 auto var(--space-5);
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, #fef7e0 0%, #fde68a 50%, #fcd34d 100%);
    border-radius: 18px;
    font-size: 1.75rem;
    transition:
      transform 0.4s cubic-bezier(0.16, 1, 0.3, 1),
      background 0.4s ease,
      box-shadow 0.4s ease;
    box-shadow:
      0 4px 12px rgba(201, 169, 97, 0.12),
      inset 0 1px 0 rgba(255, 255, 255, 0.5);
  }

  /* Icon pulse glow */
  .stat-icon::before {
    content: '';
    position: absolute;
    inset: -10px;
    background: radial-gradient(circle, var(--shadow-gold-glow, rgba(201, 169, 97, 0.25)) 0%, transparent 70%);
    border-radius: 50%;
    opacity: 0;
    transition: opacity 0.4s ease;
  }

  .stat-card:hover .stat-icon::before {
    opacity: 1;
    animation: iconPulse 2s ease-in-out infinite;
  }

  .stat-card.animating .stat-icon::before {
    opacity: 0.8;
    animation: iconPulse 1.2s ease-in-out infinite;
  }

  @keyframes iconPulse {
    0%, 100% { transform: scale(1); opacity: 0.5; }
    50% { transform: scale(1.2); opacity: 1; }
  }

  .stat-card:hover .stat-icon {
    transform: scale(1.12) rotate(5deg);
    background: linear-gradient(135deg, var(--gold, #C9A961) 0%, var(--gold-dark, #B89350) 100%);
    box-shadow:
      0 8px 24px var(--shadow-gold-glow-strong, rgba(201, 169, 97, 0.45)),
      inset 0 1px 0 rgba(255, 255, 255, 0.3);
  }

  /* Value - FIXED: Using solid color fallback that works with gradient */
  .stat-value {
    font-family: var(--font-display);
    font-size: clamp(2.25rem, 4vw, 3rem);
    font-weight: 800;
    margin-bottom: var(--space-2);
    line-height: 1.1;
    font-variant-numeric: tabular-nums;
    /* Base state: Dark gradient text */
    color: var(--blue-deeper, #1E40AF);
    background: var(--text-gradient-blue, linear-gradient(135deg, #1e3a5f 0%, #2563eb 100%));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    transition:
      color 0.4s ease,
      background 0.4s ease,
      filter 0.4s ease;
  }

  /* Animating state: Gold shimmer */
  .stat-value.animating {
    color: var(--gold, #C9A961);
    background: var(--text-gradient-gold, linear-gradient(135deg, var(--gold-dark, #B89350) 0%, var(--gold, #C9A961) 100%));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    filter: drop-shadow(0 2px 4px rgba(201, 169, 97, 0.2));
  }

  /* Hover: Gold gradient on dark glass - FIXED */
  .stat-card:hover .stat-value {
    color: var(--gold-light, #D4C5A0);
    background: linear-gradient(135deg, var(--gold, #C9A961) 0%, #E5D5AA 50%, var(--gold-light, #D4C5A0) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    filter: drop-shadow(0 2px 8px rgba(201, 169, 97, 0.3));
  }

  .counter-number,
  .counter-suffix {
    display: inline;
  }

  /* Label - FIXED: Proper color transitions */
  .stat-label {
    font-size: 0.9375rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.75px;
    /* Base state: Readable on light background */
    color: var(--gray-600, #4B5563);
    transition: color 0.4s ease;
  }

  /* Hover: White label on dark glass - FIXED */
  .stat-card:hover .stat-label {
    color: var(--text-on-dark-secondary, rgba(255, 255, 255, 0.95));
  }

  /* ========================================
     SCROLL REVEAL
     ======================================== */
  .stat-card-reveal {
    opacity: 0;
    transform: translateY(30px) scale(0.97);
    transition:
      opacity 0.7s cubic-bezier(0.16, 1, 0.3, 1),
      transform 0.7s cubic-bezier(0.16, 1, 0.3, 1);
  }

  .stat-card-reveal.visible {
    opacity: 1;
    transform: translateY(0) scale(1);
  }

  /* Stagger with longer delays for elegance */
  .stat-card-reveal[data-index="0"].visible { transition-delay: 0ms; }
  .stat-card-reveal[data-index="1"].visible { transition-delay: 120ms; }
  .stat-card-reveal[data-index="2"].visible { transition-delay: 240ms; }
  .stat-card-reveal[data-index="3"].visible { transition-delay: 360ms; }

  /* ========================================
     RESPONSIVE
     ======================================== */
  @media (max-width: 768px) {
    .trust-bar {
      padding: var(--space-12) 0;
    }

    .trust-grid {
      grid-template-columns: repeat(2, 1fr);
      gap: var(--space-4);
    }

    .stat-card {
      padding: var(--space-6) var(--space-4);
      border-radius: 20px;
    }

    .stat-icon {
      width: 52px;
      height: 52px;
      font-size: 1.5rem;
      border-radius: 14px;
    }

    .stat-value {
      font-size: clamp(1.75rem, 3.5vw, 2.25rem);
    }

    .stat-label {
      font-size: 0.8125rem;
      letter-spacing: 0.5px;
    }
  }

  @media (max-width: 480px) {
    .trust-grid {
      grid-template-columns: 1fr 1fr;
      gap: var(--space-3);
    }

    .stat-card {
      padding: var(--space-5) var(--space-3);
    }
  }

  /* ========================================
     REDUCED MOTION
     ======================================== */
  @media (prefers-reduced-motion: reduce) {
    .stat-card-reveal {
      opacity: 1;
      transform: none;
      transition: none;
    }

    .stat-card.pulse {
      animation: none;
    }

    .stat-icon::before {
      animation: none;
    }

    .trust-orb-1,
    .trust-orb-2 {
      animation: none;
    }

    .stat-card:hover {
      transform: translateY(-4px);
    }

    .stat-card:hover .stat-icon {
      transform: scale(1.05);
    }
  }
</style>

<script is:inline>
  document.addEventListener('DOMContentLoaded', () => {
    const section = document.getElementById('practice-trust');
    if (!section) return;

    const cards = section.querySelectorAll('.stat-card-reveal');
    const statValues = section.querySelectorAll('.stat-value');

    // Check for reduced motion
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    // Counter animation with easeOutExpo
    const animateCounter = (element, target, duration = 2000) => {
      return new Promise((resolve) => {
        const counterNumber = element.querySelector('.counter-number');
        if (!counterNumber) {
          resolve();
          return;
        }

        const card = element.closest('.stat-card');
        const startTime = performance.now();

        // Add animating class
        element.classList.add('animating');
        card?.classList.add('animating');

        const updateCounter = (currentTime) => {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);

          // Ease-out-expo for smooth deceleration
          const easeOutExpo = 1 - Math.pow(2, -10 * progress);
          const current = Math.round(target * easeOutExpo);

          counterNumber.textContent = current.toString();

          if (progress < 1) {
            requestAnimationFrame(updateCounter);
          } else {
            counterNumber.textContent = target.toString();
            element.classList.remove('animating');
            card?.classList.remove('animating');

            // Add pulse effect at the end
            card?.classList.add('pulse');
            setTimeout(() => card?.classList.remove('pulse'), 500);

            resolve();
          }
        };

        requestAnimationFrame(updateCounter);
      });
    };

    // Reset counter quickly
    const resetCounter = (element, duration = 400) => {
      return new Promise((resolve) => {
        const counterNumber = element.querySelector('.counter-number');
        if (!counterNumber) {
          resolve();
          return;
        }

        const currentValue = parseInt(counterNumber.textContent) || 0;
        const startTime = performance.now();

        const updateCounter = (currentTime) => {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const current = Math.round(currentValue * (1 - progress));

          counterNumber.textContent = current.toString();

          if (progress < 1) {
            requestAnimationFrame(updateCounter);
          } else {
            counterNumber.textContent = '0';
            resolve();
          }
        };

        requestAnimationFrame(updateCounter);
      });
    };

    // Run all counter animations with stagger
    const runCounterAnimations = async () => {
      const animations = [];
      statValues.forEach((value, index) => {
        const target = parseInt(value.dataset.target) || 0;
        if (target > 0) {
          animations.push(
            new Promise(resolve => {
              setTimeout(() => {
                animateCounter(value, target).then(resolve);
              }, index * 200);
            })
          );
        }
      });
      await Promise.all(animations);
    };

    // Reset all counters
    const resetAllCounters = async () => {
      const resets = [];
      statValues.forEach((value, index) => {
        resets.push(
          new Promise(resolve => {
            setTimeout(() => {
              resetCounter(value).then(resolve);
            }, index * 100);
          })
        );
      });
      await Promise.all(resets);
    };

    // Cyclic animation every 6 seconds
    let cycleInterval = null;
    const startCyclicAnimation = () => {
      cycleInterval = setInterval(async () => {
        await resetAllCounters();
        await new Promise(r => setTimeout(r, 300));
        await runCounterAnimations();
      }, 6000);
    };

    if (prefersReducedMotion) {
      cards.forEach(card => card.classList.add('visible'));
      // Show final values without animation
      statValues.forEach(value => {
        const counterNumber = value.querySelector('.counter-number');
        const target = value.dataset.target || '0';
        if (counterNumber) counterNumber.textContent = target;
      });
      return;
    }

    // Scroll reveal
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          cards.forEach((card, i) => {
            setTimeout(() => card.classList.add('visible'), i * 100);
          });

          // Start counter animation after cards are visible
          setTimeout(() => {
            runCounterAnimations().then(() => {
              startCyclicAnimation();
            });
          }, 500);

          observer.disconnect();
        }
      });
    }, { threshold: 0.2 });

    observer.observe(section);

    // Spotlight mouse tracking
    cards.forEach(card => {
      card.addEventListener('mousemove', (e) => {
        const rect = card.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        card.style.setProperty('--mouse-x', `${x}px`);
        card.style.setProperty('--mouse-y', `${y}px`);
      });
    });

    // Cleanup on page leave
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && cycleInterval) {
        clearInterval(cycleInterval);
        cycleInterval = null;
      }
    });
  });
</script>
