---
import { getEntry } from 'astro:content';

const statsData = await getEntry('stats', 'home');

if (!statsData?.data) {
  throw new Error("Stats data not found from content collection");
}

const { stats } = statsData.data;
---

<section id="stats" class="relative py-20 bg-linear-to-b from-[#1e3a5f]/4 via-[#dbeafe] to-[#e0f2fe] overflow-hidden">
  <!-- Decorative background elements with floating animation -->
  <div class="absolute inset-0 pointer-events-none">
    <div class="absolute top-0 right-0 w-[500px] h-[500px] rounded-full blur-[120px] opacity-[0.12] bg-[radial-gradient(circle,var(--blue-primary)_0%,transparent_70%)] animate-[float_20s_ease-in-out_infinite]"></div>
    <div class="absolute bottom-0 left-0 w-[400px] h-[400px] rounded-full blur-[100px] opacity-[0.08] bg-[radial-gradient(circle,var(--gold)_0%,transparent_70%)] animate-[float_25s_ease-in-out_infinite_reverse]"></div>
  </div>
  
  <div class="container relative z-10">
    <!-- Section Header -->
    <div class="text-center mb-12 opacity-0 stats-header">
      <span class="inline-flex items-center gap-2 px-4 py-2 bg-white/80 backdrop-blur-sm rounded-full border border-(--gray-200) text-sm font-semibold text-(--gray-700) mb-4">
        <i class="fas fa-chart-line text-(--gold)"></i>
        Resultados que hablan
      </span>
      <h2 class="text-[clamp(2rem,4vw,3rem)] font-bold text-(--gray-900)" style="font-family: var(--font-display);">
        Nuestro Impacto en <span class="text-gradient-gold">NÃºmeros</span>
      </h2>
    </div>

    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-8">
      {stats.map((stat, index) => (
        <div 
          class="stat-item flex items-center gap-5 p-8 bg-(--gray-50) rounded-2xl transition-all duration-300 shadow-(--shadow-premium) hover:-translate-y-2 hover:scale-[1.03] hover:shadow-(--shadow-premium-hover) will-change-[transform,opacity]"
          data-index={index}
        >
          <!-- Icon -->
          <div class="stat-icon w-[72px] h-[72px] flex items-center justify-center bg-linear-to-br from-(--blue-primary) to-(--blue-dark) rounded-[14px] shrink-0 transition-transform duration-500">
            <i class={`${stat.icon} text-[2rem] text-white`}></i>
          </div>
          
          <!-- Content -->
          <div class="flex-1">
            <div 
              class="stat-number text-[3rem] font-bold text-(--blue-primary) leading-none after:content-['+'] after:text-(--gold)"
              style="font-family: var(--font-display);"
              data-target={stat.target}
            >
              0
            </div>
            <div class="text-(--gray-600) text-[0.9375rem] font-medium mt-2">
              {stat.label}
            </div>
          </div>
        </div>
      ))}
    </div>
  </div>
</section>

<script>
  // Counter animation with smooth easing
  const animateCounter = (element: HTMLElement, target: number, duration: number = 2000): Promise<void> => {
    return new Promise((resolve) => {
      const startTime = performance.now();
      
      const updateCounter = (currentTime: number) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Easing function (ease-out-expo for smooth deceleration)
        const easeOutExpo = 1 - Math.pow(2, -10 * progress);
        const current = Math.round(target * easeOutExpo);
        
        element.textContent = current.toString();
        
        if (progress < 1) {
          requestAnimationFrame(updateCounter);
        } else {
          element.textContent = target.toString();
          resolve();
        }
      };
      
      requestAnimationFrame(updateCounter);
    });
  };

  // Reset counter to 0 with quick animation
  const resetCounter = (element: HTMLElement): Promise<void> => {
    return new Promise((resolve) => {
      const current = parseInt(element.textContent || '0', 10);
      const duration = 400;
      const startTime = performance.now();
      
      const updateCounter = (currentTime: number) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const value = Math.round(current * (1 - progress));
        
        element.textContent = value.toString();
        
        if (progress < 1) {
          requestAnimationFrame(updateCounter);
        } else {
          element.textContent = '0';
          resolve();
        }
      };
      
      requestAnimationFrame(updateCounter);
    });
  };

  // Cyclic animation - runs every 5 seconds with elegant stagger
  const startCyclicAnimation = (statItems: NodeListOf<Element>) => {
    const CYCLE_INTERVAL = 6000; // 6 seconds between cycles
    const STAGGER_DELAY = 200; // 200ms between each stat for elegant cascade
    
    const runCycle = async () => {
      const items = Array.from(statItems);
      
      for (let i = 0; i < items.length; i++) {
        const item = items[i] as HTMLElement;
        const numberEl = item.querySelector('.stat-number') as HTMLElement;
        const iconEl = item.querySelector('.stat-icon') as HTMLElement;
        
        if (numberEl && numberEl.dataset.target) {
          setTimeout(async () => {
            // Add pulse effect to card and icon
            item.classList.add('pulsing');
            if (iconEl) iconEl.classList.add('icon-pulse');
            
            const target = parseInt(numberEl.dataset.target!, 10);
            await resetCounter(numberEl);
            await animateCounter(numberEl, target, 1800);
            
            item.classList.remove('pulsing');
            if (iconEl) iconEl.classList.remove('icon-pulse');
          }, i * STAGGER_DELAY);
        }
      }
    };
    
    // Start the interval
    setInterval(runCycle, CYCLE_INTERVAL);
  };

  // Initialize scroll-triggered animations
  const initStatsAnimation = () => {
    let hasAnimated = false;
    const statsSection = document.querySelector('#stats');
    const statsHeader = document.querySelector('.stats-header');
    const statItems = document.querySelectorAll('.stat-item');
    
    // Check for reduced motion preference
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    
    if (prefersReducedMotion) {
      // Show everything immediately without animation
      statsHeader?.classList.add('visible');
      statItems.forEach((item, index) => {
        const statItem = item as HTMLElement;
        statItem.classList.add('visible');
        const numberEl = statItem.querySelector('.stat-number') as HTMLElement;
        if (numberEl && numberEl.dataset.target) {
          numberEl.textContent = numberEl.dataset.target;
        }
      });
      return;
    }
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !hasAnimated) {
          hasAnimated = true;
          
          // Animate header first
          statsHeader?.classList.add('visible');
          
          // Animate stat items with elegant stagger
          statItems.forEach((item, index) => {
            const statItem = item as HTMLElement;
            const delay = 200 + (index * 150); // Start after header, stagger each item
            
            setTimeout(() => {
              statItem.classList.add('visible');
              
              // Start counter animation after card appears
              setTimeout(() => {
                const numberEl = statItem.querySelector('.stat-number') as HTMLElement;
                if (numberEl && numberEl.dataset.target) {
                  const target = parseInt(numberEl.dataset.target, 10);
                  animateCounter(numberEl, target, 2000);
                }
              }, 300);
            }, delay);
          });
          
          // Start cyclic animation after all initial animations complete
          setTimeout(() => {
            startCyclicAnimation(statItems);
          }, 4000);
          
          observer.disconnect();
        }
      });
    }, { 
      threshold: 0.2,
      rootMargin: '0px 0px -50px 0px' // Trigger slightly before element is fully visible
    });

    if (statsSection) {
      observer.observe(statsSection);
    }
  };

  // Run on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initStatsAnimation);
  } else {
    initStatsAnimation();
  }
</script>

<style>
  /* Header animation */
  .stats-header {
    transform: translateY(20px);
    transition: opacity 0.8s cubic-bezier(0.16, 1, 0.3, 1), 
                transform 0.8s cubic-bezier(0.16, 1, 0.3, 1);
  }
  
  .stats-header.visible {
    opacity: 1;
    transform: translateY(0);
  }
  
  /* Stat item entrance animation */
  .stat-item {
    opacity: 0;
    transform: translateY(40px) scale(0.95);
  }
  
  .stat-item.visible {
    opacity: 1;
    transform: translateY(0) scale(1);
    transition: opacity 0.7s cubic-bezier(0.16, 1, 0.3, 1), 
                transform 0.7s cubic-bezier(0.16, 1, 0.3, 1);
  }
  
  /* Staggered entrance delays via CSS for smoother animation */
  .stat-item[data-index="0"].visible { transition-delay: 0ms; }
  .stat-item[data-index="1"].visible { transition-delay: 100ms; }
  .stat-item[data-index="2"].visible { transition-delay: 200ms; }
  .stat-item[data-index="3"].visible { transition-delay: 300ms; }
  
  /* Pulse effect during cyclic animation */
  .stat-item.pulsing {
    animation: statPulse 0.5s cubic-bezier(0.16, 1, 0.3, 1);
  }
  
  .stat-item.pulsing .stat-number {
    color: var(--gold);
    transition: color 0.4s ease;
  }
  
  /* Icon pulse animation */
  .stat-icon.icon-pulse {
    animation: iconPulse 0.6s cubic-bezier(0.16, 1, 0.3, 1);
  }
  
  @keyframes statPulse {
    0% {
      transform: scale(1);
      box-shadow: 
        0 1px 2px 0 rgba(0, 0, 0, 0.05),
        0 4px 12px 0 rgba(0, 0, 0, 0.08),
        0 16px 32px 0 rgba(0, 0, 0, 0.12);
    }
    50% {
      transform: scale(1.04);
      box-shadow: 
        0 0 0 4px rgba(201, 169, 97, 0.12),
        0 8px 24px rgba(201, 169, 97, 0.2),
        0 1px 2px 0 rgba(0, 0, 0, 0.05),
        0 4px 12px 0 rgba(0, 0, 0, 0.08),
        0 16px 32px 0 rgba(0, 0, 0, 0.12);
    }
    100% {
      transform: scale(1);
      box-shadow: 
        0 1px 2px 0 rgba(0, 0, 0, 0.05),
        0 4px 12px 0 rgba(0, 0, 0, 0.08),
        0 16px 32px 0 rgba(0, 0, 0, 0.12);
    }
  }
  
  @keyframes iconPulse {
    0% {
      transform: scale(1) rotate(0deg);
    }
    50% {
      transform: scale(1.1) rotate(-5deg);
    }
    100% {
      transform: scale(1) rotate(0deg);
    }
  }
  
  /* Hover state enhancements */
  .stat-item:hover .stat-icon {
    transform: scale(1.05) rotate(-3deg);
  }
  
  .stat-item:hover .stat-number {
    color: var(--gold);
    transition: color 0.3s ease;
  }
</style>
